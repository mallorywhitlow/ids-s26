---
title: "Homework Assignment 2"
author: "Mallory Whitlow"
toc: true
number-sections: true
highlight-style: pygments
format: 
  html: 
    code-fold: false
    html-math-method: katex
  pdf: 
    geometry: 
      - top=30mm
      - left=20mm
    execute:
    python:
    /Users/mallorywhitlow/Library/Caches/org.R-project.R/R/reticulate/uv/cache/archive-v0/4U3Top4DyZtpH6ks0kRRh/bin/python3

##  docx: Never, unless to accommodate a collaborator
---

## 6.2.1 Part 1. Contributing to Class Notes

This section contains a guide on how to contribute to the class note repository.

### Create a fork of the notes repository

Creating a fork is essentially the same thing as copying a repository. We need to copy the repository so that the changes we make do not conflict with the original code.

1.  In HuskyCT, click the "Homework Descriptions" link, which will take you to the `Homework` section in the class notes.
2.  Go to the section called `Preliminaries` , then click the <https://github.com/statds/ids-s26> link to be taken to the Intro to Data Science Spring 2026 class notes on Github.
3.  In the `code` tab, the fork button is on the top right corner of the screen. Click **Fork**-\> **Create Fork**
4.  Once clicking **Fork**, you should arrive on a screen with the forked class notes repository.

### Clone forked repository to computer

Use the following code in the terminal to clone the forked repository to your computer. Make sure to replace Github_Username with your Github username.

```{bash}
cd ~/Documents/Github
```

I cloned the repository into the Github folder on my computer, so either replace "Github" with the folder you would like to clone to or skip this part and use the code below to clone.

```{bash}
git clone https://github.com/Github_Username/ids-s26.git
```

```{bash}
cd ids-s26
```

### Render the class notes 

1.  Create a virtual environment to work with this repository.

    These commands create and open a folder within the class notes that runs the Python built-in virtual environment module. This gives us a clean environment so that we do not have to install packages globally and potentially mess with other coding projects.

```{bash}
python -m venv hw2
```

```{bash}
source hw2/bin/activate 
```

2.  Install the required packages from the class notes.

```{bash}
pip install -r requirements.txt
```

3.  Render the notes using Quarto, then preview them. I rendered all of the notes and it took a while, so I would suggest only rendering the parts that you want to change.

```{bash}
quarto render
```

```{bash}
quarto preview
```

### Adding homework to Github

At this point, I wanted to commit this homework into my repository. To do that, I must first clone the homework 2 repository to my local machine.

```{bash}
git clone git@github.com:ds-uconn/homework-2-mallorywhitlow.git
```

After the repository was cloned, I then added the homework file, hw2.qmd, into the cloned repository directory.

```{bash}
git add .
```

Once it was added, I committed the changes to be pushed.

```{bash}
git commit -m "Adding hw2.qmd to the homework 2 repository"
```

### Making a new branch

To experiment with adding my wishes to the wishlist on the class notes, I created a new branch so that I don't commit any changes that I don't want to save later on. This branch was created off of main in the IDS-s26 repo.

```{bash}
git checkout -b "mall-exp"
```

To make sure I was in the right branch I used this command:

```{bash}
git branch
```

It should have a star next to the name of the branch you are already in. In my case, the star was on "mall-exp", so I was all set. If it isn't, you can use this command to switch between branches.

```{bash}
git checkout "mall-exp"
git checkout "main"
```

### Adding my wishes to the class notes

I did this by opening the index.qmd file in R studio and adding my name alphabetically to the list. When I saved the file, I checked the running html link in local host on my browser to see my changes. The changes were found succesfully on http://localhost:4048/.

### Committing My Changes to GitHub

Since my changes looked nice, I pushed them to GitHub. First, commit the changes.

```{bash}
git add . #this adds all new changes to the stack
git commit -m "Adding wishes to the class wishlist"
```

Now push these changes to the branch on GitHub.

I ran into an issue where I was pushing over https and I needed to push over SSH. So I switched the remote to SSH.

```{bash}
git remote set-url origin git@github.com:mallorywhitlow/ids-s26.git
```

I was then able to push. I use origin and the branch name because this is the first time I am pushing something in this branch to GitHub.

```{bash}
git push origin "mall-exp"
```

Once I successfully pushed, I could then see my changes in GitHub under the mall-exp branch.

### Making a Pull Request

When I went to the GitHub repo, there was a message at the top stating that branch "[mall-exp](https://github.com/mallorywhitlow/ids-s26/tree/mall-exp)" had recent pushes, with a green button saying "compare and pull request".

Push this button, create a title for your pull request, and click "pull request".

When our pull request is accepted, our changes will be made to the original class notes repository for everyone to see.

### Repeat for Presentation Topic

This section will be less detailed since we already did most of these steps for the wishlist.

1.  I created a new branch called "pres"

```{bash}
git checkout -b "pres"
```

2.  Checked which branch I was in, and there was a star next to pres

```{bash}
git branch
```

3.  Went to index.qmd to add my presentation topic. Added my name and topic to the end of the list because my name was not on it, but anyone else can just add their topic next to their name
4.  I saved my changed and checked the local host to make sure they looked good.
5.  Committed the changes, then pushed them to Github using the same code as earlier, but with the branch name "pres"
6.  Compared and submitted a pull request

## **6.2.2 Part 2. Generalized “Fibonacci-like” recurrence**

### 1. Based on the Fibonacci example in the notes, implement four functions:

Naive Recursion

```{python}
def seq_rs(n, c1, c2):
    if n == 1 or n == 2:
        return 1
    return c1 * fib_rs(n-1) + c2 * fib_rs(n-2)

```

Memoization

```{python}
def seq_dm_helper(n, c1, c2, mem):
    if mem[n] is not None:
        return mem[n]
    elif n == 1 or n == 2:
        result = 1
    else:
        result = (
            c1 * seq_dm_helper(n - 1, c1, c2, mem)
            + c2 * seq_dm_helper(n - 2, c1, c2, mem)
        )
    mem[n] = result
    return result


def seq_dm(n, c1, c2):
    if not isinstance(n, int) or n < 1:
        raise ValueError("n must be a positive integer")
    if not isinstance(c1, int) or not isinstance(c2, int):
        raise ValueError("c1 and c2 must be integers")

    mem = [None] * (n + 1)
    return seq_dm_helper(n, c1, c2, mem)

```

Bottom up with list

```{python}
def seq_dbu(n, c1, c2):
    if not isinstance(n, int) or n < 1:
        raise ValueError("n must be a positive integer")
    if not isinstance(c1, int) or not isinstance(c2, int):
        raise ValueError("c1 and c2 must be integers")

    if n <= 2:
        return 1

    mem = [None] * (n + 1)
    mem[1] = 1
    mem[2] = 1

    for i in range(3, n + 1):
        mem[i] = c1 * mem[i - 1] + c2 * mem[i - 2]

    return mem[n]

```

Bottom up with constant memory

```{python}
def seq_dbu_m(n, c1, c2):
    if not isinstance(n, int) or n < 1:
        raise ValueError("n must be a positive integer")
    if not isinstance(c1, int) or not isinstance(c2, int):
        raise ValueError("c1 and c2 must be integers")

    if n <= 2:
        return 1

    a, b = 1, 1

    for _ in range(3, n + 1):
        a, b = b, c1 * b + c2 * a

    return b

```

### Verification

```{python}
for f in [seq_rs, seq_dm, seq_dbu, seq_dbu_m]:
    print(f.__name__, f(10, 2, 1))
```

```{python}
import timeit
import pandas as pd

methods = [
    ("Naive Recursion", seq_rs),
    ("Memoization", seq_dm),
    ("Bottom-Up List", seq_dbu),
    ("Bottom-Up Constant", seq_dbu_m),
]

ns = [10, 20, 40]
coeffs = [(1, 1), (2, 1)]

rows = []

for n in ns:
    for c1, c2 in coeffs:
        for name, func in methods:
            t = timeit.timeit(lambda: func(n, c1, c2), number=1)
            rows.append([name, n, c1, c2, t])

df = pd.DataFrame(rows, columns=["Method", "n", "c1", "c2", "Time (seconds)"])

df

```

Naive recursion repeatedly computes the same values, causing the number of function calls to grow exponentially; as n increases, there is also a very large increase in runtime.

Memoization stores previously computed results and reuses them. This gets rid of repeated work, since each value is only computed once.

The bottom up list method stores all computed values in a list, so it uses more memory as n increases. The constant memory version only keeps the last two values, so it uses much less memory.

## **6.2.3 Part C. Fast method using matrices**

```{python}
# A 2x2 matrix is represented as:
# [[a, b],
#  [c, d]]

def mat2_mul(A, B):
    """Multiply two 2x2 matrices A and B."""
    return [
        [
            A[0][0] * B[0][0] + A[0][1] * B[1][0],
            A[0][0] * B[0][1] + A[0][1] * B[1][1],
        ],
        [
            A[1][0] * B[0][0] + A[1][1] * B[1][0],
            A[1][0] * B[0][1] + A[1][1] * B[1][1],
        ],
    ]

def mat2_vec_mul(A, v):
    """Multiply 2x2 matrix A by 2-vector v = [x, y]."""
    return [
        A[0][0] * v[0] + A[0][1] * v[1],
        A[1][0] * v[0] + A[1][1] * v[1],
    ]

def mat2_pow(M, n):
    """
    Compute M^n for a 2x2 matrix M and integer n >= 0
    using exponentiation by squaring.
    """
    if not isinstance(n, int) or n < 0:
        raise ValueError("n must be an integer >= 0")

    # Identity matrix I
    result = [[1, 0],
              [0, 1]]
    base = M

    while n > 0:
        if n % 2 == 1:
            result = mat2_mul(result, base)
        base = mat2_mul(base, base)
        n //= 2

    return result


# Quick sanity checks
I = [[1, 0], [0, 1]]
A = [[2, 3], [4, 5]]

assert mat2_mul(I, A) == A
assert mat2_mul(A, I) == A
assert mat2_pow(A, 0) == I
assert mat2_pow(A, 1) == A
```

```{python}
def seq_log(n, c1, c2, a1=1, a2=1):
    
    if n == 1:
        return a1
    if n == 2:
        return a2

    M = [[c1, c2],
         [1,  0]]

    Mn = mat2_pow(M, n - 2)

    result_vec = mat2_vec_mul(Mn, [a2, a1])

    return result_vec[0]
```

```{python}
seq_log(10, 2, 1)
```

```{python}
import time
def benchmark(n, c1=2, c2=1):
    print(f"\nBenchmark n = {n}")
    
    start = time.perf_counter()
    result1 = seq_dbu_m(n, c1, c2)
    t1 = time.perf_counter() - start
    print(f"seq_dbu_m: {t1:.6f} seconds")

    start = time.perf_counter()
    result2 = seq_log(n, c1, c2)
    t2 = time.perf_counter() - start
    print(f"seq_log:   {t2:.6f} seconds")

    assert result1 == result2
```

```{python}
benchmark(10**3)
benchmark(10**4)
benchmark(10**5)
```

The biggest takeaway for me is that algorithm choice matters a lot more than I originally thought. Even though all of the methods compute the same sequence, reducing the recurrence to matrix exponentiation changes the complexity from O(n) to O(log n). For large n values, this creates an extreme difference in performace, and puts into perspective how big of a role math plays in runtime efficiency.
